Rocket.Chat Apps-Engine 
The Rocket.Chat Apps-Engine is a solution designed to streamline app development and enhance delivery speed. This platform empowers developers to create and operate applications within Rocket.Chat's infrastructure, leveraging pre-built components for ease and efficiency. It offers a comprehensive framework, enabling the development of secure, scalable apps that seamlessly integrate with Rocket.Chat functionalities.

Key features of the Apps-Engine include:
Security compliance: Rocket.Chat ensures the highest standards of data privacy, security, and ownership for the apps developed on its platform.

Robust server support: Utilizing the same infrastructure as Rocket.Chat, the Apps-Engine ensures effective traffic management and access to the latest features and updates. Apps run in a JavaScript runtime environment, ensuring compatibility and performance.

Reduced launch time: The platform simplifies the development process by providing pre-built components to create various app features.

This guide provides a comprehensive overview of creating Rocket.Chat apps using the Apps-Engine. It covers the basics of app creation, extending functionalities with slash commands, HTTP requests, event handlers, and interactive UI elements. Additionally, it delves into app configuration, data persistence, and other advanced features. Developers also have the opportunity to submit their apps to the Rocket.Chat Marketplace for public use or keep them private for their workspace.

The Rocket.Chat Marketplace serves as a hub for users to integrate various apps into their workspace, offering a platform for both publishing and installing developed apps.

For more information on installing and enabling apps in your workspace, refer to the Rocket.Chat Marketplace resources.

Getting Started with Apps-Engine 
Documentation
Apps-Engine
Getting Started with Apps-Engine
Throughout the entire process, an active internet connection is required.

Prerequisites
Before beginning, the following must be installed on your machine:

Git

Node.js (version 12 and above)

Rocket.Chat Apps-Engine CLI

A code editor. We recommend Visual Studio Code (VSCode).

A local development instance of Rocket.Chat must be running on your system.

To develop a Rocket.Chat App, you must write TypeScript code. Although the Apps-Engine CLI manages the majority of definitions, you must grasp where the code guides you to comprehend how your application interacts with the Rocket.Chat server and external APIs.

About Rocket.Chat server
To test your applications, you will need an active server. Ideally, this would be a test environment so as not to impact the production environment. The following components are related to the Rocket.Chat server and there is no action required from your end:

Server management and package manager: To develop a full-stack JavaScript application, a server-side JavaScript runtime, and a package manager are required. Node.js can be used as the server environment, as it can serve files and connect to the database using JavaScript. For the package manager, we recommend using Yarn due to its faster library installation, better security features, and reliability in managing dependencies.

Database: You need a database to store your application data. The Rocket.Chat server uses MongoDB as a database to store all chat messages, user information, and other system configurations and related data.

About Node.js VM module
Node.js is a cross-platform, open-source JavaScript runtime environment extensively used to develop server-side and networking applications. Node.js is designed on top of Chrome's V8 engine, allowing developers to run Javascript programs exceptionally quickly by compiling them directly to machine code.

The virtual machine (VM) module is a fundamental feature of Node.js that allows developers to execute programs in a VM context. The VM module provides access to APIs for compiling and executing code within the context of a V8 VM. The Rocket.Chat Apps-Engine is built on top of the Node.js VM module; therefore, most of the environment configuration will involve launching the VM module within your Rocket.Chat workspace.

About context

With the help of the VM module, a context is an alternative environment that is created. This environment consists solely of key-value pairings, each of which runs directly on top of the V8 engine.

The aim of using the Node.js VM module was to isolate each app on its own scope, preventing them from interacting directly with the host Rocket.Chat server or other apps, so they couldn't inject data and disrupt the system or expose data from other sources. In addition, it is also to avoid the complication of spawning, controlling, and managing the communication of external processes to execute these logics.


Create an App 
Documentation
Apps-Engine
Create an App
In this document, you will learn about the Apps-Engine commands and create a basic app.

Apps-Engine CLI commands
rc-apps is a command-line interface (CLI) utility that provides commands to rapidly develop a Rocket.Chat application. Initiate rc-apps in your terminal to view the list of commands that you can execute as needed.

Here is a list of commands that Rocket.Chat Apps-Engine supports:

Command

Description

Example

autocomplete

Displays installation instructions.

Note: This command is not supported on Windows.

rc-apps autocomplete

create

Simplifies the process of creating an app.

rc-apps create

deploy

Deploys an app to the server.

rc-apps deploy --url <server_url> -u <user> -p <pwd>

generate

Creates boilerplate code files in the current directory for the following:

API extension: Enter the name and path of the endpoint. The .ts file is created in a new endpoints folder.

Slash command extension: Enter the name of the command class that you want to create. The .ts file is created in a new slashCommands folder.

Settings extension: A settings.ts file is created.

rc-apps generate

help

Displays the CLI tool for helping with Rocket.Chat Apps.

rc-apps help

login

Provides the steps for logging into Rocket.Chat Cloud.

rc-apps login

logout

Revokes the Rocket.Chat Cloud credentials.

rc-apps logout

package

Packages the app for distribution.

rc-apps package

submit

Submits an app to the marketplace for review.

rc-apps submit

watch

Monitors app changes and redeploys the modified app to the server.

rc-apps watch

Create a basic app
Now that you've understood the basic concepts of the Apps-Engine and installed the CLI, let's build our initial app Hello World.

Make sure that you have the setup environment ready.

Step 1: Execute the create command
To create a new app, in the command line, execute rc-apps create.

Enter the following app details:

App Name: Hello World

App Description: A basic app that prints Hello World!

Author’s Name: John

Author’s Home Page: rocketchat.com

Author’s Support Page: support.rocketchat.com

A folder with the app name is created in the current working directory (in this case, hello-world). The hello-world folder contains a simple app that will only compile and be packaged in the dist folder.

Troubleshooting tip

If you receive the error message 'TypeError: Cannot read properties of undefined [reading 'message']', do not be alarmed. You can disregard this and use the cd <folder-name> command to determine if a folder for your application was created.

Step 2: Open the app folder in Visual Studio
Launch Visual Studio and select Open Folder from the sidebar on the left.

Select the app folder that was created in the previous step.

Once the folder has been uploaded, its contents will be displayed in the sidebar.

Step 3: Comprehend the structure of the app
The app manifest file app.json contains basic details about the app:

{
    "id": "28d63257-94c3-40e8-83eb-9581244598b6",
    "version": "0.0.1",
    "requiredApiVersion": "^1.4.0",
    "iconFile": "icon.png",
    "author": {
        "name": "John",
        "homepage": "rocketchat.com",
        "support": "support@rocketchat.com"
    },
    "name": "Hello World",
    "nameSlug": "hello-world",
    "classFile": "HelloWorldApp.ts",
    "description": "A basic app that prints Hello World!"
}
JSONCopy
A Rocket.Chat app is a TypeScript project that contains a main file with a class extending the main App class from the Apps-Engine. The identity of this file can be found in the classFile property of your app.json file. For this example, locate and open the HelloWorldApp.ts TypeScript file.

The following code snippet shows the class in the HelloWorldApp.ts file:

export class HelloWorldApp extends App {
    constructor(info: IAppInfo, logger: ILogger, accessors: IAppAccessors) {
        super(info, logger, accessors);
    }
}
TypeScriptCopy
Observe that the class name and filename are identical. This is intentional. You can either use the same name for the class and the file for the application to compile successfully, or export the primary app class by default as shown below:

export default class HelloWorldApp extends App {
    // ...
}
TypeScriptCopy
For a functioning app, you must define a constructor to access a large number of parent properties. The constructor accepts three arguments:

An IAppInfo object: This object contains fundamental information about your application, such as its name, version, description, etc. It is private to the App class, but its properties are accessible through multiple GET methods.

An ILogger object: This object is the interface for logging. The getLogger() method allows access to this object from within a child class.

An IAppAccessors object: This object contains all app accessors. This can be accessed via the getAccessors() method in the child class.

Learn more about the module details from the Rocket.Chat Apps Typescript definition.

Step 4: Implement the app functionality
For this example, the app records "Hello, World!" in the Rocket.Chat administration interface.

To log data, you must first have access to the logger, that is, an object of type ILogger. The parent class logs data to the administration interface using an ILogger object. We only require access to this object. Since the logger object is private to the App class, the this keyword cannot be used to access it directly.

To resolve this, use the getLogger method provided by the App class. You need to store the logger as a separate object that can be reused whenever necessary.

Modify the class in the HelloWorldApp.ts file as follows:

export class HelloWorldApp extends App {
    private readonly appLogger: ILogger
    
    constructor(info: IAppInfo, logger: ILogger, accessors: IAppAccessors) {
        super(info, logger, accessors)
        this.appLogger = this.getLogger()
    }
}
TypeScriptCopy
We have just stored the accessor for the log file in the appLogger variable. Now, we can record anything with it. Add the line shown below to the constructor and save the file.

this.appLogger.debug('Hello, World!')
TypeScriptCopy
Step 5: Deploy to the server
In the command line, go to the hello-world app folder that was created in Step 1: Execute the create command. To deploy the app, run:

rc-apps deploy --url <server_url> -u <user> -p <pwd>
BashCopy
Replace <server_url> with the URL of your Rocket.Chat workspace.

Replace <user> and <pwd> with your username and password, respectively.

After executing this command, your application will be deployed to the server.

To explore alternative authentication options for deploying your app, such as using 2FA codes or personal access tokens, run the  rc-apps deploy --help  command.

Packaging your app

Alternatively, you can execute the rc-apps package command. This gives you a compressed zip file of your app that you can upload as a private app to your Rocket.Chat server.

Step 6: Test the app
To test your app, you need a Rocket.Chat server running locally on your machine and the credentials of an administrator user.

In older versions of Rocket.Chat, you might need to enable apps development mode for manual installations to be allowed.

To enable apps development mode:

Go to Administration > General > Apps.

Click True next to Enable development mode.

To run Rocket.Chat in develop mode, see the development environment setup guide.

In this example, the function of the application is to log Hello, World! to the console. To test the app's functionality, we must examine the app logs.

Follow these steps to examine the logs:

Login to your Rocket.Chat workspace as an admin.

Navigate to the Administration Panel.

Under Apps, select Marketplace.

Select Private Apps from the left-hand menu. You should see the Hello World app.

Click on the three dots icon on the right-hand side of the app. From the menu, click on View Logs.

The App Info page opens on the Logs tab. Scroll down until you see the "constructor" expandable section. Select it and you can see the message "Hello, World!" logged in the console.

Congratulations, you just created your first app — a simple Hello World app!

To learn how to add more functionalities to your app, proceed to the next topic.


Slash Command Examples 
Documentation
Apps-Engine
Extend App Capabilities
Slash Commands
Slash Command Examples
In this section, we'll look at two slash command examples:

Update user status value and text.

Extend messages to include an image attachment and custom field.

Update user status
To update the user status, we will create a new slash command that takes two parameters:

The first parameter is the status value - online, away, busy, etc.

The second contains the status text.

We will refer to the status slash command as st to execute code such as:

/st away Doing code :)
Plain textCopy
Step 1: Create the slash command
To implement this, follow these steps:

Create a new class named StatusUpdateCmd.ts and place it in the same subdirectory commands that we created in the previous section.

Now, add the following code for the status update:

import {
    IHttp,
    IModify,
    IPersistence,
    IRead,
} from '@rocket.chat/apps-engine/definition/accessors';
import { IRoom } from '@rocket.chat/apps-engine/definition/rooms';
import {
    ISlashCommand,
    SlashCommandContext,
} from '@rocket.chat/apps-engine/definition/slashcommands';
import { IUser } from '@rocket.chat/apps-engine/definition/users';

export class StatusUpdateCmd implements ISlashCommand {
   public command = 'st';
   public i18nParamsExample: string = 'status_update_command_params_example';
   public i18nDescription: string = 'status_update_command_description';
   public providesPreview: boolean = false;
   
   public async executor(context: SlashCommandContext, read: IRead, modify: IModify, http: IHttp, persis: IPersistence): Promise<void> {
       const user = context.getSender();
       const params = context.getArguments();
       const room: IRoom = context.getRoom();
       
       if (!params || params.length == 0) {
           return this.notifyMessage(room, read, user, "At least one status argument is mandatory. A second argument can be passed as status text.");
       }
       
       let status = params[0];
       let statusText = params.length > 1 ? params.slice(1).join(' ') : '';
       
       await modify.getUpdater().getUserUpdater().updateStatus(user, statusText, status);
       await this.notifyMessage(room, read, user, "Status updated to " + status + " (" + statusText + ").");
   }
   
   private async notifyMessage(room: IRoom, read: IRead, sender: IUser, message: string): Promise<void> {
       const notifier = read.getNotifier();
       const messageBuilder = notifier.getMessageBuilder();
       messageBuilder.setText(message);
       messageBuilder.setRoom(room);
       return notifier.notifyUser(sender, messageBuilder.getMessage());
    }
}
TypeScriptCopy
Here, we are implementing the following:

Fetch the status value from the first argument. This argument is mandatory otherwise, the notifyMessage method informs the user that the argument is missing.

Fetch the status message from the second argument, joining the terms with a white space. If the second argument is not passed, the status message remains an empty string.

Update the status according to the value passed using modify.

Notify the user about the status update.

Step 2: Register the slash command
In the app's main class, register the new slash command as follows:

public async extendConfiguration(configuration: IConfigurationExtend) {
        configuration.slashCommands.provideSlashCommand(new StatusUpdateCmd());
}
TypeScriptCopy
You can only have one extendConfiguration method in your app's main class. Therefore, make sure to add all your slash commands to this method.

Make sure to import the slash command class in the main class:

import { StatusUpdateCmd } from './commands/StatusUpdateCmd';
TypeScriptCopy
All that remains is deployment and testing!

Step 3: Deploy the app
In the command line, go to the app folder and run:

rc-apps deploy --url <server_url> -u <user> -p <pwd>
BashCopy
The <server_url> parameter is the URL of your Rocket.Chat server.

Replace the placeholders with the URL, username, and password for your server, respectively.

After executing this command, your application will be deployed to the server.

Packaging your app

Alternatively, you can execute the rc-apps package command. This gives you a compressed zip file of your app that you can upload as a private app to your Rocket.Chat server.

Step 4: Test the app
Send /st <status> <message> to any channel. You can see the change in the user status accordingly.


If we execute /st with no input, we receive the notification:


Extend messages
This example explains how to modify messages to include custom fields and attachments. We will construct an app that is invoked via a slash command, sends a message, and is extended to include an image and a custom field.

Step 1: Add attachments
Rocket.Chat supports numerous attachments (and applicable customizations for these attachments). For instance, you can attach images, documents, videos, and audio files to messages. The first step in doing so is to create your own attachment class.

In this approach, we will implement the ImageAttachment class in the project's root as follows:

import { IMessageAttachment } from '@rocket.chat/apps-engine/definition/messages';

export class ImageAttachment implements IMessageAttachment{
    imageUrl?: string;

    constructor(imgUrl: string){
        this.imageUrl = imgUrl;
    }
}
TypeScriptCopy
Here, we use a class attribute with the same identifier and type as in the IMessageAttachment interface, which is required for your linked media to be visible to the user. This is because only the variables in your attachment class defined in the IMessageAttachment interface will be used to retrieve the attachment's media.

You can also construct your own classes for video or audio attachments, or you can group them all into a single class that can accommodate all of these possibilities. Make sure to use the same attributes described in the IMessageAttachment.d.ts file.

The audio and video formats that are supported in the Rocket.Chat message attachments are identical to HTML audio and video elements.

Step 2: Create the slash command
To implement this, follow these steps:

Create a new class named ExtendMessageCommand.ts and place it in the same subdirectory commands that we created in the previous section.

Now, add the following code:

import { IHttp, IModify, IPersistence, IRead, IMessageExtender } from '@rocket.chat/apps-engine/definition/accessors';
import { ISlashCommand, SlashCommandContext } from '@rocket.chat/apps-engine/definition/slashcommands';
import { ImageAttachment } from '../ImageAttachment';

export class ExtendMessageCommand implements ISlashCommand{
    public command = 'extend-message';
    public i18nParamsExample = '';
    public i18nDescription = '';
    public providesPreview = false;

    public async executor(context: SlashCommandContext, read: IRead, modify: IModify, http: IHttp, persis: IPersistence): Promise<void> {
        const messageId = await this.sendMessage(context, modify, 'Sending a message!'); // [1]
        const messageExtender = await this.getMessageExtender(context, modify, messageId); // [2]
        const value = 1;
        const img = new ImageAttachment('https://open.rocket.chat/images/logo/logo.svg'); // [3]

        messageExtender.addCustomField('key', value); // [4]
        messageExtender.addAttachment(img); // [5]

        await modify.getExtender().finish(messageExtender); // [6]
    }
}
TypeScriptCopy
The main actions performed by the code above are:

[1] Sends a message and stores the sent message's ID in the messageId variable.

[2] Uses the sent message's ID. The messageExtender object is returned by the getMessageExtender method and stored in the messageExtender variable.

[3] Creates the attachment object as an instance of the ImageAttachment class. Here, the attachment is an image.

[4] Adds a custom field with the key 'key' linked to the value using the addCustomField method from the messageExtender object. Many more custom fields can be added to the same message by calling the same method with distinct keys (and values of your choice).

[5] Adds the image attachment to the message using the addAttachment method from the messageExtender object. Many attachments can be added all at once using the addAttachments method.

[6] Finishes the modifyExtender object, which is crucial to apply the extensions made to the message and make them visible to the user.

Custom fields
Custom fields are structures linked to messages in which each field is organized as if it were an entry in a dictionary. That is, each field must contain a key and corresponding value. These elements are retained in the server's database along with the corresponding messages so that they can be retrieved later.

Step 3: Create auxiliary methods
It is beneficial to define a few additional methods within our slash command class so that our code remains concise and straightforward.

Method: sendMessage

The sendMessage method needs to return the message's ID after it has been sent. The method must now return a Promise<string> as opposed to a Promise<void>.

The modified sendMessage method is shown below:

private async sendMessage(context: SlashCommandContext, modify: IModify, message: string): Promise<string> {
    const messageStructure = modify.getCreator().startMessage();
    const sender = context.getSender();
    const room = context.getRoom();

    messageStructure
        .setSender(sender)
        .setRoom(room)
        .setText(message);

    return modify.getCreator().finish(messageStructure); // [1]
}
TypeScriptCopy
Method: getMessageExtender

After obtaining the message's ID, we can get the messageExtender object, which enables the addition of custom fields and attachments.

To obtain the messageExtender object, use the following asynchronous method in the slash command class:

private async getMessageExtender(context: SlashCommandContext, modify: IModify, messageId: string): Promise<IMessageExtender>{
    const sender = context.getSender();
    return modify.getExtender().extendMessage(messageId, sender); // [1]
}
TypeScriptCopy
Here, we use the message's ID returned by the sendMessage method to obtain the messageExtender object using the modifyExtender object.

After creating the methods, you only need to invoke them with a slash command.

Step 4: Register the slash command
We must register the slash command in the app's main class, the project's root.

import { App } from '@rocket.chat/apps-engine/definition/App';
import { IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';
import { ExtendMessageCommand } from './slashcommands/ExtendSlashcommand'; // [1]

export class RocketChatTester extends App {
    constructor(info: IAppInfo, logger: ILogger, accessors: IAppAccessors) {
        super(info, logger, accessors);
    }

    public async extendConfiguration(configuration: IConfigurationExtend) {
        configuration.slashCommands.provideSlashCommand(new ExtendMessageCommand()); // [2]
    }
}
TypeScriptCopy
Here, we import our new slash command class and register it in the app's configuration.

Step 5: Deploy the app
To deploy the app, follow the deployment steps highlighted in the previous example.

Step 6: Test the slash command
After the app has been deployed, execute the slash command /extend-message in any channel.

When you execute the registered slash command, a message is sent to the current channel and altered to include an image attachment and a custom field. The attached image is visible in the message after editing. In addition, the created custom fields are accessible from any database client of your choosing.



Email - Event Interfaces 
The table below contains the email-related events, as well as the purpose of each event. If you want to execute actions based on email events, you can use any of the events mentioned below as an event interface.

Interface

Description

IPreEmailSent

The event interface allows apps to register as a handler of the IPreEmailSent event.

This event is triggered before the mailer sends an email.

To prevent the email from being sent, you can throw an error with a message specifying the reason for rejection.

Livechat - Event Interfaces 
The table below contains the livechat-related events, as well as the purpose of each event. If you want to execute actions based on livechat events, you can use any of the following events and methods:

Interface

Description

IPostLivechatAgentAssigned

The handler called after the assignment of a livechat agent.

IPostLivechatAgentUnassigned

The handler called after the livechat agent is unassigned.

IPostLivechatGuestSaved

The handler called after the guest's information is saved.

IPostLivechatRoomClosed

The handler called after a livechat room is closed.

IPostLivechatRoomSaved

The handler called after the room information is saved.

IPostLivechatRoomStarted

The handler called after a livechat room starts.

IPostLivechatRoomTransferred

The handler called after a livechat room is transferred.

You can find additional interfaces and details on the Apps TypeScript definition page.




Message - Event Interfaces 
Documentation
Apps-Engine
Extend App Capabilities
Event Interfaces and Handlers
Message - Event Interfaces
The table below contains the message-related events, as well as the purpose of each event. If you want to execute actions based on message events, you can use any of the events mentioned below as an event interface. Find more details in the Rocket.Chat Apps TypeScript Definition.https://rocketchat.github.io/Rocket.Chat.Apps-engine/modules/messages.html

Interface

Description

IPostMessageDeleted

The handler after a message is deleted.

IPostMessageFollowed

The handler after a message has been followed or unfollowed.

IPostMessagePinned

The handler after a message is pinned or unpinned.

IPostMessageReacted

The handler after a message gets a reaction or a reaction is removed.

IPostMessageReported

The handler after a message is reported.

IPostMessageSent

The handler after a message is sent.

IPostSystemMessageSent

This event is triggered whenever a system message is sent. For a list of system messages, see the MessageType.ts file.

IPostMessageSentToBot

The handler after a DM is sent to a bot.

IPostMessageStarred

The handler after a message has been starred or unstarred.

IPostMessageUpdated

The handler after a message is updated.

IPreMessageDeletePrevent

The handler used to determine whether a user is allowed to delete a message or not.

IPreMessageSentExtend

The handler called when an app wants to extend a message.

IPreMessageSentModify

The handler called when an app wants to modify a message.

IPreMessageSentPrevent

The handler which is called to determine whether a user is allowed to send a message or not.

IPreMessageUpdatedExtend

The handler called when an app wants to extend a message update.

IPreMessageUpdatedModify

​​The handler called when an app wants to modify a message update.

IPreMessageUpdatedPrevent

The handler which is called to determine whether a user is allowed to update a message or not.

Room - Event Interfaces 
Documentation
Apps-Engine
Extend App Capabilities
Event Interfaces and Handlers
Room - Event Interfaces
The table below contains the room-related events, as well as the purpose of each event. If you want to execute actions based on room events, you can use any of the events mentioned below as an event interface.

Interface

Description

IPostRoomCreate

Handler after a room is created.

IPostRoomDeleted

Handler after a room is deleted.

IPostRoomUserJoined

Event interface that allows an app to register as a handler of the IPostRoomUserJoined event.

This event is triggered after a user successfully joins a room. This event does not allow an app to prevent any action from happening. For that, see the IPreRoomUserJoined interface.

IPostRoomUserLeave

Event interface that allows an app to register as a handler of the IPostRoomUserLeave event.

This event is triggered after a user successfully leaves a room. This event does not allow an app to prevent any action from happening. For that, see the IPreRoomUserLeave interface.

IPreRoomCreateExtend

Handler called when an app wants to extend a room.

IPreRoomCreateModify

​​Handler called when an app wants to modify a room.

IPreRoomCreatePrevent

Handler called when an app wants to prevent the creation of a room.

IPreRoomDeletePrevent

Handler called when an app wants to prevent the deletion of a room.

IPreRoomUserJoined

Event interface that allows an app to register as a handler of the IPreRoomUserJoined event.

This event is triggered prior to a user successfully joining a room. To prevent the user from executing such an action, an app should throw the UserNotAllowedException. This event is not triggered before a room has been created. For that, check the IPreRoomCreate event.

IPreRoomUserLeave

Event interface that allows an app to register as a handler of the IPreRoomUserLeave event.

This event is triggered prior to a user successfully leaving a room. To prevent the user from executing such an action, an app should throw the UserNotAllowedException. This event is not triggered before a room has been created. For that, check the IPreRoomCreate event.


Settings - Event Interfaces 
The table below contains the settings-related events, as well as the purpose of each event. If you want to execute actions based on settings events, you can use any of the events mentioned below as an event interface.

Interface

Description

ISetting

Interface that represents a setting and fetches details of the setting such as ID, type, value, and so on.

ISettingUpdateContext

The context of execution for the event - ISettingUpdate.

SettingType

Interface that represents the setting type and fetches details of the type of setting configured for the app.

Uploads - Event Interfaces 
The table below contains the upload-related events, as well as the purpose of each event. If you want to execute actions based on upload events, you can use any of the events mentioned below as an event interface.

Interface

Description

IPreFileUpload

Event interface that allows an app to register as a handler of the IPreFileUpload event.

This event is triggered prior to an upload successfully being saved to the database, but only after all its contents have been retrieved by Rocket.Chat. To prevent the upload from completing, an app should throw a FileUploadNotAllowedException with a message specifying the reason for rejection.


Users - Event Interfaces 
The table below contains the user-related events, as well as the purpose of each event. If you want to execute actions based on user events, you can use any of the events mentioned below as an event interface.

Interface

Description

IPostUserCreated

Event interface that allows an app to register as a handler of the IPostUserCreated event. This event is triggered after the user is saved to the database.

IPostUserDeleted

Event interface that allows an app to register as a handler of the IPostUserDeleted event. This event is triggered after the user has been removed from the database.

IPostUserLoggedIn

Event interface that allows an app to register as a handler of the IPostUserLoggedIn event. This event is triggered after the user logs into Rocket.Chat.

IPostUserLoggedOut

Event interface that allows an app to register as a handler of the IPostUserLoggedOut event. This event is triggered after the user logs out from Rocket.Chat.

IPostUserStatusChanged

Event interface that allows an app to register as a handler of the IPostUserStatusChanged event. This event is triggered after the user changes his status on Rocket.Chat to online, away, busy, or offline. It is not triggered when the custom status is changed.

IPostUserUpdated

Event interface that allows an app to register as a handler of the IPostUserUpdated event. This event is triggered after the user is saved to the database.


Event Interface Examples 
Documentation
Apps-Engine
Extend App Capabilities
Event Interfaces and Handlers
Event Interface Examples
Now that we have learned about the event interfaces, let's go through some examples to implement them. On this page, we will follow three examples:

Messaging governance

Notify messages

Content inspection

Messaging governance
In this example, we will use the IPreMessageSentPrevent interface to control whether a particular message should be sent to a channel. We are using our Hello World app to test this.

Open your app folder in Visual Studio and select the main app file, in this case, HelloWorldApp.ts.

To the HelloWorldApp class, add the IPreMessageSentPrevent interface as follows:

export class TestApp extends App implements IPreMessageSentPrevent {
TypeScriptCopy
As soon as we add the indication of implements IPreMessageSentPrevent we see that Visual Studio displays an error that it cannot find the interface and shows the option to quickly fix it in a tooltip. Click it to display different import options that would fix the issue. Import the following interface:

import { IPreMessageSentPrevent } from '@rocket.chat/apps-engine/definition/messages/IPreMessageSentPrevent';
TypeScriptCopy
Now Visual Studio will display an error that a certain method part of the interface has its implementation missing with the option to fix it quickly. Accept the suggested fix. Visual Studio adds two methods of the interface that are not implemented. The methods will throw an error when executed. But now, we have a skeleton code to work with:

checkPreMessageSentPrevent?(message: IMessage, read: IRead, http: IHttp): Promise<boolean> {
        throw new Error('Method not implemented.');
}

executePreMessageSentPrevent(message: IMessage, read: IRead, http: IHttp, persistence: IPersistence): Promise<boolean> {
    throw new Error('Method not implemented.');
}
TypeScriptCopy
With the checkPreMessageSentPrevent method, we will only check the messages from channels other than general. Visual Studio helps you navigate through the APIs of the classes of the objects by suggesting the available methods. For this example, you can see that the method variable message has a room attribute which has a slugifiedName string attribute. Update the method as follows:

checkPreMessageSentPrevent?(message: IMessage, read: IRead, http: IHttp): Promise<boolean> {
        return message.room.slugifiedName != 'general';
}
TypeScriptCopy
Now Visual Studio displays an error that the method signature is not compatible with returning a Promise<boolean>. To fix this issue, add async to the method signature.

Next, implement the executePreMessageSentPrevent method. If the message equals "test", we prevent it from being published.

Your main app file should look something like this:

import {
    IAppAccessors,
    IHttp,
    ILogger,
    IPersistence,
    IRead,
} from '@rocket.chat/apps-engine/definition/accessors';
import { App } from '@rocket.chat/apps-engine/definition/App';
import { IMessage } from '@rocket.chat/apps-engine/definition/messages';
import { IPreMessageSentPrevent } from '@rocket.chat/apps-engine/definition/messages/IPreMessageSentPrevent';
import { IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';

export class HelloWorldApp extends App implements IPreMessageSentPrevent {
    constructor(info: IAppInfo, logger: ILogger, accessors: IAppAccessors) {
        super(info, logger, accessors);
        logger.debug('Hello, World!');
    }
    
    async checkPreMessageSentPrevent?(message: IMessage, read: IRead, http: IHttp): Promise<boolean> {
        return message.room.slugifiedName != 'general';
    }
    
    async executePreMessageSentPrevent(message: IMessage, read: IRead, http: IHttp, persistence: IPersistence): Promise<boolean> {
        return message.text == 'test';
    }
}
TypeScriptCopy
Save the file and deploy your app.

If we send the test message in a channel other than general, it should not be published (it will appear grayed out). If the message is something different it will get sent. As for the room general, all messages will be sent, including test as shown in the following screenshots:

image(55).png
image(56).png
Notify messages
In this example, we will notify the general channel whenever a message is sent anywhere else. Here we will implement the IPostMessageSent interface.

Like the previous example, in the main app file (in this case, HelloWorldApp.ts), we will add the check and execute methods from the IPostMessageSent interface as shown in the code below.

The check method confirms that the general channel exists and fetches it.

In the execute method, for the general channel, we create a message containing information about the message published, the room, and the sender by getting the values from sendMessage. The messageBuilder allows us to define richly formatted messages.

import {
   IAppAccessors,
   IHttp,
   ILogger,
   IModify,
   IPersistence,
   IRead,
} from '@rocket.chat/apps-engine/definition/accessors';
import { App } from '@rocket.chat/apps-engine/definition/App';
import { IMessage, IPostMessageSent } from '@rocket.chat/apps-engine/definition/messages';
import { IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';
import { IRoom } from '@rocket.chat/apps-engine/definition/rooms/IRoom';
import { IUser } from '@rocket.chat/apps-engine/definition/users/IUser';

export class HelloWorldApp extends App implements IPostMessageSent {
   constructor(info: IAppInfo, logger: ILogger, accessors: IAppAccessors) {
       super(info, logger, accessors);
       logger.debug('Hello, World!');
   }
   
   async checkPostMessageSent?(message: IMessage, read: IRead, http: IHttp): Promise<boolean> {
       return message.room.slugifiedName != 'general';
   }
   
   async executePostMessageSent(message: IMessage, read: IRead, http: IHttp, persistence: IPersistence, modify: IModify): Promise<void> {
       const general = await read.getRoomReader().getByName('general');
       if (!general) {
           return;
       }
       const msg = `@${message.sender.username} said "${message.text}" in #${message.room.displayName}`;
       const author = await read.getUserReader().getAppUser();
       if (general.id != message.room.id) { // prevent this for running on #general channel
           await this.sendMessage(general, msg, author?author:message.sender, modify);
       }
   }
   
   private async sendMessage(room: IRoom, textMessage: string, author: IUser, modify: IModify) {
       const messageBuilder = modify.getCreator().startMessage({
           text: textMessage,
       } as IMessage);
       messageBuilder.setRoom(room);
       messageBuilder.setSender(author);
       return modify.getCreator().finish(messageBuilder);
   }
}
TypeScriptCopy
Now save, deploy, and test the app. You should be able to see the warning messages posted to the general channel when writing to any other channel.

image(57).png
Content inspection
A typical use case of the previous two examples is to control the content of the information being exchanged. For instance, we could use regular expressions matching inappropriate words to flag them.

Some apps that implement content inspection are:

Data Loss Prevention (DLP)

Antivirus (ClamAV)

Word Replacer

For our Hello World app, let's look into inspecting file attachments.

In our main app file, we will implement IPreFileUpload and print a message notifying the user that the attached file is inspected.

If the file type is text/plain, we will log the file's content also.

import {
    IAppAccessors,
    IHttp,
    ILogger,
    IModify,
    IPersistence,
    IRead,
} from '@rocket.chat/apps-engine/definition/accessors';
import { App } from '@rocket.chat/apps-engine/definition/App';
import { AppMethod, IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';
import { IRoom } from '@rocket.chat/apps-engine/definition/rooms/IRoom';
import { IFileUploadContext, IPreFileUpload } from '@rocket.chat/apps-engine/definition/uploads';
import { IUser } from '@rocket.chat/apps-engine/definition/users/IUser';

export class HelloWorldApp extends App implements IPreMessageSentPrevent, IPostMessageSent, IPreFileUpload {
    public async executePreFileUpload(context: IFileUploadContext, read: IRead, http: IHttp, persis: IPersistence, modify: IModify): Promise<void> {
        console.log('ContentInspectionExampleAppApp - File Uploaded - Name: ' + context.file.name);
        console.log('ContentInspectionExampleAppApp - File Uploaded - Type: ' + context.file.type);
        console.log('ContentInspectionExampleAppApp - File Uploaded - Size: ' + context.file.size);
 

        if (context.file.type == 'text/plain') {
            console.log('ContentInspectionExampleAppApp - File Uploaded - Content: ' +
                String.fromCharCode.apply(null, context.content));
        }

        //if file was bad we could throw an exception
        //throw new FileUploadNotAllowedException('File is Bad');
        const user = await read.getUserReader().getById(context.file.userId);
        const room = await read.getRoomReader().getById(context.file.rid);
        if (room) {
            await this.notifyMessage(room, read, user, 'File inspected - Check logs');
        }
    }
    
    private async notifyMessage(room: IRoom, read: IRead, sender: IUser, message: string): Promise<void> {
        const notifier = read.getNotifier();
        const messageBuilder = notifier.getMessageBuilder();
        messageBuilder.setText(message);
        messageBuilder.setRoom(room);
        return notifier.notifyUser(sender, messageBuilder.getMessage());
    }
}
TypeScriptCopy
Save the file and deploy the app. Send an attachment to a room to test the app. The notification is like a temporary private message visible only to the user who sent the attachment (if you refresh the page, the notification is gone).

image(58).png
Great! With these examples, you have learned how to implement event interfaces and react to certain events. You have made significant progress in expanding your app!

In the upcoming sections, we will look at another way to extend your app's capabilities by creating interactive user experiences with the Apps-Engine UIKit.


HTTP Requests 
Documentation
Apps-Engine
Extend App Capabilities
HTTP Requests
HTTP requests are the next feature we will look at to expand your app functionality. If you want to connect your app to the outside world, the HTTP property enables users to invoke an external web service.

In this topic, we will create a slash command get for our Hello World app. This command executes a GET HTTP request based on the given URL. You can also use our tester app or any app of your choice. Make sure that a Rocket.Chat server is ready to deploy the app.

Step 1: Register the slash command
The slash command must be registered in the app's main class, at the root of the project.

import { IAppAccessors, IConfigurationExtend, ILogger } from '@rocket.chat/apps-engine/definition/accessors';
import { App } from '@rocket.chat/apps-engine/definition/App';
import { IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';
import { HTTPRequestCommand } from './commands/HTTPRequestCommand'; // [1]

export class HelloWorldApp extends App {
    constructor(info: IAppInfo, logger: ILogger, accessors: IAppAccessors) {
        super(info, logger, accessors);
    }

    public async extendConfiguration(configuration: IConfigurationExtend) {
        configuration.slashCommands.provideSlashCommand(new HTTPRequestCommand()); // [2]
    }
}
TypeScriptCopy
Here, we import our new slash command class and then register it in the app's configuration.

Step 2: Create the slash command
If you haven't created a separate directory for slash commands, it is recommended to create a commands directory at the root of the project.

Create the HTTPRequestCommand.ts file in this directory.

Then enter the code shown below:

import {
    IHttp,
    IModify,
    IRead,
} from '@rocket.chat/apps-engine/definition/accessors';
import {
    ISlashCommand,
    SlashCommandContext,
} from '@rocket.chat/apps-engine/definition/slashcommands';

export class HTTPRequestCommand implements ISlashCommand {
    public command = 'get'; // [1]
    public i18nParamsExample = '';
    public i18nDescription = '';
    public providesPreview = false;

    public async executor(context: SlashCommandContext, read: IRead, modify: IModify, http: IHttp): Promise<void> {
        const [url] = context.getArguments(); // [2]

        if (!url) { // [3]
            throw new Error('Error!');
        }

        await http.get(url); // [4]
    }
}
TypeScriptCopy
This code implements the following:

The slash command is called get.

When executed, it uses the argument that the user passed after the command as the URL.

The argument is mandatory. If no argument is provided, an error is thrown.

Perform the GET request using the provided argument.

Optionally, you can store the GET request in a console constant. When the command is executed, it is logged.

const response = await http.get(url);
console.log("result: " + response.data);
TypeScriptCopy
Step 3: Print the request to a conversation
Now, instead of logging console output to the instance's log, let's output it to the conversation.

Add the following private method to HTTPRequestCommand.ts.

private async sendMessage(context: SlashCommandContext, modify: IModify, message: string): Promise<void> {
    const messageStructure = modify.getCreator().startMessage();
    const sender = context.getSender(); // [1]
    const room = context.getRoom(); // [2]

    messageStructure
        .setSender(sender)
        .setRoom(room)
        .setText(message); // [3]

    await modify.getCreator().finish(messageStructure); // [4]
}
TypeScriptCopy
This function implements the following:

Gets the user who invoked the command (in this case, you).

Selects the room where the command was executed.

Sets the received string as the message.

Sends the message to the room.

Then, append the following code to the end of the executor method:

const response = await http.get(url);
const message = JSON.stringify(response.data, null, 2);
await this.sendMessage(context, modify, message);
TypeScriptCopy
Instead of simply sending the request and not capturing the response, we store the response in a constant, format its content as a string, and transmit it using our new sendMessage method.

Note: To learn more about messaging, see the IMessageBuilder documentation.

Step 4: Deploy the app
To deploy the app, run:

rc-apps deploy --url <server_url> -u <user> -p <pwd>
BashCopy
The <server_url> parameter is the URL of your Rocket.Chat server.

Replace the placeholders with the URL, username, and password for your server, respectively.

After executing this command, your application will be deployed to the server.

Packaging your app

Alternatively, you can execute the rc-apps package command. This gives you a compressed zip file of your app that you can upload as a private app to your Rocket.Chat server.

Step 5: Test the app
After deploying the application, enter /get <some_url> in any channel and the app will send a GET request to the specified URL. In this example, we will use JSONPlaceholder to obtain dummy data to test our app:

Enter /get https://jsonplaceholder.typicode.com/todos/1 in a chat.

You receive the following response in the chat:

{
    "userId": 1,
    "id": 1,
    "title": "delectus aut autem",
    "completed": false
}
TypeScriptCopy
Similarly, you can apply this feature to connect with any domain of your choice.

Next, let's gain an understanding of events and the Apps-Engine-supported features to handle Rocket.Chat events.


Apps-Engine User Interface 
Documentation
Apps-Engine
Extend App Capabilities
Apps-Engine User Interface
Along with using slash commands and handling events, another way to extend an app's functionality is to add user interactions, such as buttons or menus, to perform some action. Apps-Engine's UIKit is a set of components that allow apps to interact with Rocket.Chat's UI. It provides a series of block objects that you can use and map to the components that will be displayed on the screen. In this section, you will find information about the building blocks and elements with sample code snippets to help you create user interactions for your app

Features of UIKit
Rocket.Chat provides limited components for the app interface to be built and one component adheres to the Rocket.Chat design specifications. So, it will look just like Rocket.Chat, without breaking the UX continuity for users.

Most of the interactions can also be mobile responsive, without any additional coding. This is one of the benefits of using the UIKit provided by Rocket.Chat. All you have to do is define the interaction and call the components as needed.

After you build the block objects, they will interact with the UI via the UI controller which is inside the modify accessor called getUiController().

openSurfaceView has the methods for calling the contextual bar and the modal. You just have to build your view — either the modal or contextual bar. Apps-Engine and Rocket.Chat will be able to tell which one you’re trying to display to the user. This will be defined in UIKitSurfaceType.

Some of the user interactions that you can define are as follows:

Display an overlay popup
For an app to interact with the UI, we need user consent.

TriggerID—Whenever a user interacts with the app, the app can get a trigger ID, which is like a password required in all the methods in the UI controller so that the UI components will be shown. It will only work if the app has a valid trigger ID issued by Rocket.Chat. User interactions will provide a valid trigger ID.

If a valid trigger ID is not provided, the method call will fail silently and the desired action will not take place.

Handle user interactions
When a user interacts with any UI components, it triggers other interactions. The IUIKitInteractionHandler is a handler for after a message is sent. All the methods then become available to the app.

Based on the UI component, the app receives an interaction of the specified type, and the app gets the context of what the interaction was, what data was filled, the inputs provided by the user, and so on.

Depending on the app’s functionality and flow, the user might have to input some data — such as filling out a form. IUIKitInteractionHandler helps you handle user interactions by capturing the data in the backend.

Action buttons
Apps can register action buttons in different places in the UI — in the room menu, the kebab menu, the message options, the message composer box options, and so on.

The UIActionButtonContext helps you place the action block contextually across several places within Rocket.Chat.

Read the upcoming topics for further details on each component of the UIKit and how you can leverage them for your app.


Using UIKit Blocks 
Documentation
Apps-Engine
Extend App Capabilities
Apps-Engine User Interface
Building Blocks
Using UIKit Blocks
This document covers various examples to help you use the Apps-Engine UI blocks so you can create meaningful user interactions in your apps. The UI blocks are triggered by an action or a condition. In these examples, the UI blocks will be triggered when a message is starred. First, we will see how to create a single block and then we will add more elements to create complex visual layouts.

Create a section block
Let’s create a basic section that contains some text. This will be displayed in a room when a message is starred. The main app class looks like this:

import {
    IAppAccessors, IConfigurationExtend, ILogger, IHttp, IModify, IPersistence, IRead, IMessageBuilder, IMessageRead
} from '@rocket.chat/apps-engine/definition/accessors';
import { App } from '@rocket.chat/apps-engine/definition/App';
import { IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';
import { UIKitInteractionType, IUIKitInteractionHandler, UIKitSurfaceType } from '@rocket.chat/apps-engine/definition/uikit';
import { OpenCtxBarCommand } from './contextbar';
import { uiKitMessage } from '@rocket.chat/ui-kit';
import { IMessage, IMessageStarContext, IPostMessageSent, IPostMessageStarred } from '@rocket.chat/apps-engine/definition/messages';

export class uiblocksApp extends App implements IPostMessageStarred {

    async executePostMessageStarred(context: IMessageStarContext, read: IRead, http: IHttp, persistence: IPersistence, modify: IModify): Promise<void> {
        const messageCreator = modify.getCreator().startMessage();

        messageCreator.setBlocks([
            {
                type: 'section', // the type of block
                text: {
                    type: 'plain_text',
                    text: 'Message starred! :)',
                    emoji: true
                }
            },
        ])
        messageCreator.setRoom(context.message.room);
        await modify.getCreator().finish(messageCreator);
    }
}
TypeScriptCopy
Whenever a message is starred, the app bot returns the text message as shown in this screenshot:



Stack multiple blocks
In the same example, we are going to add more blocks and elements to demonstrate how you can create complex UI layouts.

Add an image block
async executePostMessageStarred(context: IMessageStarContext, read: IRead, http: IHttp, persistence: IPersistence, modify: IModify): Promise<void> {
        const messageCreator = modify.getCreator().startMessage();

        messageCreator.setBlocks([
            {
                type: 'section', // section block
                text: {
                    type: 'plain_text',
                    text: 'Message starred! :)',
                    emoji: true
                }
            },
            {
                type: 'image', // image block
                imageUrl: 'https://cdn0.iconfinder.com/data/icons/new-year-holidays-set/200/NewYearIcon7-01-1024.png',
                altText: 'test image'
            },
        ])

        //messageCreator.setText('Message starred! :)');
        messageCreator.setRoom(context.message.room);
        await modify.getCreator().finish(messageCreator);
    }
TypeScriptCopy


Add a divider block and an action block
Now, instead of the image, we will add a divider and an action block. The action block contains a button element.

async executePostMessageStarred(context: IMessageStarContext, read: IRead, http: IHttp, persistence: IPersistence, modify: IModify): Promise<void> {
        const messageCreator = modify.getCreator().startMessage();
        const appId = this.getID();

        messageCreator.setBlocks([
            {
                type: 'section', // the section block
                blockId: 'section_1',
                text: {
                    type: 'plain_text',
                    text: 'Message starred! :)',
                    emoji: true
                }
            },
            {
                type: 'divider', // the divider block
                appId: appId,
                blockId: 'divider_block_1'
            },
            {
                type: 'actions', // the action block
                appId: appId,
                blockId: 'action_block_1',
                elements: [ // the elements parameter contains the action element details, in this case, a button element
                    {
                        type: 'button',
                        actionId: 'button_action_1',
                        appId: appId,
                        blockId: 'button_action_block_1',
                        text: {
                            type: 'plain_text',
                            text: 'Learn more!'
                        },
                        style: 'primary',
                        value: 'Button element'
                    }
                ]
            },
        ])

        //messageCreator.setText('Message starred! :)');
        messageCreator.setRoom(context.message.room);
        await modify.getCreator().finish(messageCreator);
    }
TypeScriptCopy
The following screenshot shows the UI:



Add an input block
We will define an input block containing the static menu element type:

async executePostMessageStarred(context: IMessageStarContext, read: IRead, http: IHttp, persistence: IPersistence, modify: IModify): Promise<void> {
        const messageCreator = modify.getCreator().startMessage();
        const appId = this.getID();

        messageCreator.setBlocks([
            {
                type: 'section', // the section block
                blockId: 'section_1',
                text: {
                    type: 'plain_text',
                    text: 'Message starred! :)',
                    emoji: true
                }
            },
            {
                type: 'divider', // the divider block
                appId: appId,
                blockId: 'divider_block_1'
            },
            {
                type: 'actions', // the action block
                appId: appId,
                blockId: 'action_block_1',
                elements: [ // the elements parameter contains the action element details, in this case, a button element
                    {
                        type: 'button',
                        actionId: 'button_action_1',
                        appId: appId,
                        blockId: 'button_action_block_1',
                        text: {
                            type: 'plain_text',
                            text: 'Learn more!'
                        },
                        style: 'primary',
                        value: 'Button element'
                    }
                ]
            },
            {
                type: 'input', // the input block
                appId: appId,
                blockId: 'input_block',
                label: {
                    type: 'plain_text',
                    text: 'static_input'
                },
                element: { // the "element" object contains the definition of the type of input block you want to use, in this case, a static select menu
                    type: 'static_select',
                    actionId: 'static_select_action_1',
                    appId: appId,
                    blockId: 'static_select_block_1',
                    placeholder: {
                        type: 'plain_text',
                        text: 'Select an option:',
                    },
                    options: [
                        {
                            value: 'option_1',
                            text: {
                                type: 'plain_text',
                                text: 'This is your first option'
                            }
                        },
                        {
                            value: 'option_2',
                            text: {
                                type: 'plain_text',
                                text: 'This is your second option'
                            }
                        }
                    ]
                }
            }
        ])

        //messageCreator.setText('Message starred! :)');
        messageCreator.setRoom(context.message.room);
        await modify.getCreator().finish(messageCreator);
    }
TypeScriptCopy
The following screenshot shows the blocks returned by the app bot:



Add a context block
To the previous code snippet, we will add a context block definition as follows:

{
                type: 'context', // the context block
                appId: appId,
                blockId: 'context_block',
                elements: [
                  {
                    type: 'plain_text',
                    text: 'This is a context block'
                  }
                ]
              },
        ])

        //messageCreator.setText('Message starred! :)');
        messageCreator.setRoom(context.message.room);
        await modify.getCreator().finish(messageCreator);
    }
TypeScriptCopy
The following screenshot shows what the context block looks like:



Add a preview block
To this example, we will now add a preview block as follows:

{
                type: 'preview', // the preview block
                description: [
                  {
                    type: 'plain_text',
                    text: 'Description of preview'
                  }
                ],
                title: [
                  {
                    type: 'plain_text',
                    text: 'Title of preview'
                  }
                ]
              },        
        
        ])

        //messageCreator.setText('Message starred! :)');
        messageCreator.setRoom(context.message.room);
        await modify.getCreator().finish(messageCreator);
    }
TypeScriptCopy
The following screenshot shows how the preview block appears in the UI:


Using UIKit Block Elements 
Documentation
Apps-Engine
Extend App Capabilities
Apps-Engine User Interface
Building Blocks
Using UIKit Block Elements
In the previous document, we went through examples of how to use UI blocks. Here, we will look at some examples of using block elements. Block elements are defined inside blocks. In the following examples, the UI elements will be triggered when a message is followed and unfollowed.

Add a radio button element
The main app class looks like this:

import {
    IAppAccessors,
    IHttp,
    ILogger,
    IMessageUpdater,
    IModify,
    IPersistence,
    IRead,
} from '@rocket.chat/apps-engine/definition/accessors';
import { App } from '@rocket.chat/apps-engine/definition/App';
import { IMessage, IMessageFollowContext, IPostMessageFollowed } from '@rocket.chat/apps-engine/definition/messages';
import { IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';

export class SampleAppApp extends App implements IPostMessageFollowed {

    async executePostMessageFollowed(context: IMessageFollowContext, read: IRead, http: IHttp, persistence: IPersistence, modify: IModify): Promise<void> {
        const messageCreator = modify.getCreator().startMessage();
        const appId = this.getID();

        messageCreator.setBlocks([
            {
                type: 'section', // we have added a section block to give a heading to the radio buttons
                text: {
                    type: 'plain_text',
                    text: 'Select a radio button option:'
                }
            },
            {
                type: 'actions', // the action block contains the radio button definition
                appId: appId,
                blockId: 'action_block_1',
                elements: [
                    {
                        type: 'radio_button',
                        actionId: 'radio_button_action_1',
                        appId: appId,
                        blockId: 'radio_button_action_block_1',
                        options: [
                            {
                                text: {
                                    type: 'plain_text',
                                    text: 'Option 1',
                                },
                                value: 'option_1',
                            },
                            {
                                text: {
                                    type: 'plain_text',
                                    text: 'Option 2',
                                },
                                value: 'option_2'
                            }
                        ]
                    },
                ]
            }
        ])
        
        messageCreator.setRoom(context.message.room);
        await modify.getCreator().finish(messageCreator);
    }
}
TypeScriptCopy
In the workspace, the following screenshot shows the response returned by the sample app bot when a message is followed:



Add an overflow menu
To this example, we will now add an overflow menu element after the radio buttons. Add the following definition to the messageCreator.setBlocks parameter.

{
  type: 'section', // the section block which contains the overflow menu block element
  blockId: 'section_2',
  text: {
     type: 'plain_text',
     text: 'Overflow menu', // the text displayed for the section block
   },
  accessory: { // the accessory parameter contains the overflow menu definition
     type: 'overflow',
     actionId: 'overflow_1',
     appId: appId,
     blockId: 'overflow_menu_block',
     options: [{
            value: 'option_1',
            text: {
                        type: 'plain_text',
                        text: 'This is the first option',
                        emoji: true,
                    }},
                   {
            value: 'option_2',
            text: {
                          type: 'plain_text',
                          text: 'This is the second option',
                          emoji: true,
}}]}},
TypeScriptCopy
The following screenshot shows how the overflow menu is displayed in the UI:



Add a plain text input element
To this example, we will add a plain text input element contained in an input block. Add the following code to the messageCreator.setBlocks parameter:

{
  type: 'input', // the input block
  label:{ // a label for the input block
    type: 'plain_text',
    text: 'Plain text input'
  },
  element: { // the definition of the plain text input element
    type: 'plain_text_input',
    appId: appId,
    actionId: 'plain_text_input_action_1',
    blockId: 'plain_text_input_block_1',
    placeholder: {
       type: 'plain_text',
       text: 'Enter the text input here'
  },
  multiline: false
}},
TypeScriptCopy
The following screenshot shows the plain text input in the UI:



Add a linear scale element
A linear scale element is defined in an action block. Add the following code to the messageCreator.setBlocks parameter:

{
  type: 'actions', // the action block
  appId: appId,
  blockId: 'action_block_3',
  elements: [{ // the definition of the linear scale element
      type: 'linear_scale',
      actionId: 'linear_scale_action_1',
      appId: appId,
      blockId: 'linear_scale_action_block_1',
      minValue: 0,
      maxValue: 10,
      initialValue: 0,
      preLabel: {
          type: 'plain_text',
          text: 'Min value'
       },
      postLabel: {
          type: 'plain_text',
          text: 'Max value'
}}]},
TypeScriptCopy
The following screenshot shows how the linear scale element looks like in the workspace:



Add a checkbox element
A checkbox element is defined in an action block. Add the following code to the messageCreator.setBlocks parameter:

{
   type: 'section', // the section block - adds a text heading to the checkbox action block
   text: {
      type: 'plain_text',
      text: 'Select a checkbox option:'
}},
{
   type: 'actions', // the action block contains the checkbox element definition
   appId: appId,
   blockId: 'action_block_4',
   elements: [{
       type: 'checkbox',
       actionId: 'checkbox_action_1',
       appId: appId,
       blockId: 'checkbox_action_block_1',
       options: [{
           text: {
              type: 'plain_text',
              text: 'Option 1'
                 },
           value: 'option_1',
            },
     {
           text: {
              type: 'plain_text',
              text: 'Option 2',
            },
           value: 'option_2'
}]}]},
TypeScriptCopy
The following screenshot shows the checkbox element displayed on the UI:



Add date picker and time picker elements
Add the following code to the messageCreator.setBlocks parameter:

{
   type: 'actions', // the action block
   blockId: 'action_block_5',
   elements: [ // the elements parameter contains the date picker block element definition
   {
       type: 'datepicker',
       appId: appId,
       blockId: 'date_block_1',
       actionId: 'date_action_1',
   }]},
{
   type: 'actions', // another action block that contains the time picker element definition
   appId: appId,
   blockId: 'action_block_6',
   elements: [{
         type: 'time_picker',
         actionId: 'time_picker_action_1',
         appId: appId,
         blockId: 'time_picker_action_block_1',
}]},
TypeScriptCopy
The following screenshot shows what the date picker element looks like on the UI:



The following screenshot shows the time picker element:

Create Contextual Bar 
Documentation
Apps-Engine
Extend App Capabilities
Apps-Engine User Interface
Building Blocks
Create Contextual Bar
A contextual bar is a sidebar displayed on the screen after the user triggers it. In this document, we will see how to use the UIKit components to create a contextual bar containing blocks and elements. Defining contextual bars and modals is a little different from the UI blocks we saw in the previous document.

To create and update contextual bars and modals, use the following methods:

modify.getUiController().openSurfaceView({type, title, blocks}, triggerId, user)
modify.getUiController().updateSurfaceView({type, title, blocks}, context, user)
TypeScriptCopy
For details on these methods, see the IUIController interface TypeScript definition.

Let’s look at a basic app to open a contextual bar that is triggered with a slash command using the openSurfaceView method.

In your app folder, create a file to define the slash command and the context bar. For example, OpenCtxBarCommand.ts.

Import the following:

import { IModify, IRead } from "@rocket.chat/apps-engine/definition/accessors";
import { App } from "@rocket.chat/apps-engine/definition/App";
import { ISlashCommand, SlashCommandContext } from "@rocket.chat/apps-engine/definition/slashcommands";
import { UIKitSurfaceType } from "@rocket.chat/apps-engine/definition/uikit";
TypeScriptCopy
Now, in the class OpenCtxBarCommand, define the slash command as follows:

export class OpenCtxBarCommand implements ISlashCommand {
  public command = 'contextualbar'; // this is what we will type when calling the slashcommand: /contextualbar
  public i18nParamsExample = 'slashcommand_params';
  public i18nDescription = 'slashcommand_description';
  public providesPreview = false;
}
TypeScriptCopy
Next, in the same class, define the context bar in the async executor method as follows:

constructor(private readonly app: App) { }

public async executor(context: SlashCommandContext, _read: IRead, modify: IModify): Promise<void> {
  modify.getUiController().openSurfaceView({
    type: UIKitSurfaceType.CONTEXTUAL_BAR, // The type of the UI, CONTEXTUAL_BAR or MODAL.
    title: { text: 'test', type: 'plain_text' }, // The title of the UI type that is displayed in the workspace.
    blocks: [{ // The content of the UI type. It can contain many elements (inputs, actions, etc.)
      type: 'section', // The type of the block.
      blockId: 'section_1', // The name of the block.
      text: { // The object contains the content that will be displayed in the contextual bar.
        type: 'plain_text',
        text: 'lorem ipsum 🚀',
        emoji: true,
      } // Additionally, the `accessory` field can contain the block elements.
    }]
  },
    { triggerId: context.getTriggerId()! }, // The trigger ID is like a security measure - to show users the contextual bar or modal only if users interacted with Rocket.Chat.
      context.getSender() // The user that types the slash command.
  )
}
}
TypeScriptCopy
See Building blocks for details on how to use the blocks.

Update the main app class to call the OpenCtxBarCommand.ts file.

import {
    IAppAccessors,
    IConfigurationExtend,
    ILogger,
} from '@rocket.chat/apps-engine/definition/accessors';
import { App } from '@rocket.chat/apps-engine/definition/App';
import { IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';
import { OpenCtxBarCommand } from './contextbar'; // import the `OpenCtxBarCommand` class

export class HelloWorldApp extends App {
    
    protected async extendConfiguration(configuration: IConfigurationExtend): Promise<void> {
        await configuration.slashCommands.provideSlashCommand(
            new OpenCtxBarCommand(this)
        )
    }
}
TypeScriptCopy
Deploy and test the app. In any channel, send the slash command /contextualbar.

The following screenshot shows the contextual bar called test with the content that we defined in the blocks.



Great! We have created a contextual bar for our app. You can now define additional UI elements for the contextual bar. For example, let’s add an image to this.

To add an image block, we can modify the OpenCtxBarCommand.ts as follows:

public async executor(context: SlashCommandContext, _read: IRead, modify: IModify): Promise<void> {
  modify.getUiController().openSurfaceView
  ({
    type: UIKitSurfaceType.CONTEXTUAL_BAR, // The type of the UI, CONTEXTUAL_BAR or MODAL.
    title: { 
             text: 'Contextual bar', 
             type: 'plain_text' }, // The title of the UI type that is displayed in the workspace.
    blocks: [{ // The content of the UI type. It can contain many elements (inputs, actions, etc.)
      type: 'section', // The type of the block.
      blockId: 'section_1', // The name of the block.
      text: { // The object contains the content that will be displayed in the contextual bar.
        type: 'plain_text',
        text: 'lorem ipsum 🚀',
        emoji: true,
      } // Additionally, the `accessory` field can contain the block elements.
    },
    {
        type: 'image', // the image block
        blockId: 'image_1',
        imageUrl: 'https://img.freepik.com/free-vector/rocket-background-flat-style_23-2147904992.jpg?size=338&ext=jpg&ga=GA1.1.2008272138.1726444800&semt=ais_hybrid',
        altText: 'An icon of a rocket',
    },
]
  },
    { triggerId: context.getTriggerId()! }, // The trigger ID is like a security measure - to show users the contextual bar or modal only if users interacted with Rocket.Chat.
      context.getSender() // The user that types the slash command.
  )
}
}
TypeScriptCopy
The contextual bar looks like this:

Create Modal 
Documentation
Apps-Engine
Extend App Capabilities
Apps-Engine User Interface
Building Blocks
Create Modal
The UI modal element is displayed in front of the page content. It is a pop-up window that can contain text or user interaction elements. The window is triggered by an action or condition. In this document, we will create a basic app that triggers a modal using a slash command.

In your app folder, create a file to define the slash command and the modal. For example, OpenModalCommand.ts.

Import the following:

import { IModify, IRead } from "@rocket.chat/apps-engine/definition/accessors";
import { App } from "@rocket.chat/apps-engine/definition/App";
import { ISlashCommand, SlashCommandContext } from "@rocket.chat/apps-engine/definition/slashcommands";
import { UIKitSurfaceType } from "@rocket.chat/apps-engine/definition/uikit";
TypeScriptCopy
In the OpenModalCommand class, define the slash command as follows:

export class OpenModalCommand implements ISlashCommand {
  public command = 'openmodal'; // this is what we will type when calling the slashcommand: /openmodal
  public i18nParamsExample = 'slashcommand_params';
  public i18nDescription = 'slashcommand_description';
  public providesPreview = false;
}
TypeScriptCopy
This slash command will trigger the modal on the screen.

In the same class, define the modal as follows:

constructor(private readonly app: App) { }

  public async executor(context: SlashCommandContext, _read: IRead, modify: IModify): Promise<void> {
    modify.getUiController().openSurfaceView(
      {
        type: UIKitSurfaceType.MODAL, // type of ui - cb or modal
        title: { // title of the modal
          text: 'hello world', // title text
          type: 'plain_text' },
        blocks: [{ // content of the modal
        type: 'section', // type of the first block
        blockId: 'section_1',
          text: { // the text object in this section
              type: 'plain_text',
              text: 'lorem ipsum 🚀',
              emoji: true,
            }
      }, 
      {
        type: 'divider', // type of the second block
        blockId: 'divider_1',
      }
     ]
    },
      { triggerId: context.getTriggerId()! }, // like security measure - to show users the ui if users interacted with rc
      context.getSender() // user that types the slash command
    )
  }
TypeScriptCopy
In this case, we have stacked two blocks - the section with text and a divider block.

Update your main app class to call the OpenModalCommand class.

Deploy and test the app. In any room, send the slash command /openmodal.

The following screenshot shows the modal with the content that we defined in the blocks:


Contextual Bar 
The openContextualBarView method is deprecated. While this method can be used at this time, it is recommended to use the openSurfaceView method instead. See the Create Contextual Bar topic for details.

A contextual bar is a sidebar displayed on the screen. You need to pass a BlockBuilder object containing the content you want to display and call the following methods:

// to create a new contextual bar
await modify.getUiController().openContextualBarView(blocks, { triggerId }, user);

// to update an existing contextual bar
await modify.getUiController().updateContextualBarView(blocks, { triggerId }, user);
TypeScriptCopy
Let's look at a sample app to open the contextual bar. This app consists of two main parts:

A slash command from where we can get a valid triggerId.

The function that opens the contextual bar using thetriggerId.

You can clone the app and test it in your own Rocker.Chat server: https://github.com/RocketChat/apps-contextual-bar-open-example

We are importing the following files:

import {
    IAppAccessors,
    IConfigurationExtend,
    IHttp,
    ILogger,
    IModify,
    IPersistence,
    IRead,
} from '@rocket.chat/apps-engine/definition/accessors';

import { App } from '@rocket.chat/apps-engine/definition/App';
import { IAppInfo } from '@rocket.chat/apps-engine/definition/metadata';
import { ISlashCommand, SlashCommandContext } from '@rocket.chat/apps-engine/definition/slashcommands';

import { BlockElementType, ISectionBlock, IUIKitResponse, UIKitBlockInteractionContext, UIKitViewSubmitInteractionContext } from '@rocket.chat/apps-engine/definition/uikit';

import { IUIKitContextualBarViewParam } from '@rocket.chat/apps-engine/definition/uikit/UIKitInteractionResponder';
TypeScriptCopy
Now we will add a class OpenCtxBarCommand that implements ISlashCommand. In this class, we are doing the following:

Define the slash command to get the trigger ID. Without the trigger ID, it is not possible to open the contextual bar.

Call the function to create the blocks that we will render inside the contextual bar.

Call the method that opens the contextual bar.

class OpenCtxBarCommand implements ISlashCommand {
    // this is what we will type when calling the slashcommand: /contextualbar
    public command = 'contextualbar';
    public i18nParamsExample = 'slashcommand_params';
    public i18nDescription = 'slashcommand_description';
    public providesPreview = false;

    constructor(private readonly app: App) {}

    public async executor(context: SlashCommandContext, _read: IRead, modify: IModify): Promise<void> {
        const triggerId = context.getTriggerId() as string; // [1]
        const user = context.getSender();

        const contextualbarBlocks = createContextualBarBlocks(modify); // [2]

        await modify.getUiController().openContextualBarView(contextualbarBlocks, {                 triggerId }, user); // [3]
    }
}

// [1] - first we get the triggerId  to open the surface (without this it would not be possible to open the contextual bar)
// [2] - then we create the blocks we will render inside the contextual bar.
// [3] - then call the method that opens the contextual bar.
TypeScriptCopy
After creating the class, we will define a method called createContextualBarBlocks to implement the following:

Create the blocks that will be rendered inside the contextual bar.

Add a section block that consists of a message that shows the current date-time and a button that refreshes the date-time shown in the message.

Return the contextual bar structure containing its title and a submit button.

function createContextualBarBlocks(modify: IModify, viewId?: string): IUIKitContextualBarViewParam {
    const blocks = modify.getCreator().getBlockBuilder();

    const date = new Date().toISOString();

    blocks.addSectionBlock({
        text: blocks.newMarkdownTextObject(`The current date-time is\n${date}`), // [4]
        accessory: { // [5]
            type: BlockElementType.BUTTON,
            actionId: 'date',
            text: blocks.newPlainTextObject('Refresh'),
            value: date,
        },
    });

    return { // [6]
        id: viewId || 'contextualbarId',
        title: blocks.newPlainTextObject('Contextual Bar'),
        submit: blocks.newButtonElement({
            text: blocks.newPlainTextObject('Submit'),
        }),
        blocks: blocks.getBlocks(),
    };
}
// This method creates the blocks that will be rendered inside the contextual bar.
// It consists of:
// [4] - a message that presents the current date-time.
// [5] - a button that updates the date-time shown in the message.
// [6] - the contextual bar structure containing its title and a submit button.
TypeScriptCopy
Finally, we will modify the main app class as follows:

Provide the slash command that we will use.

Listen for the date-time button to be clicked.

Update the contextual bar's content.

Listen for the user to click the Submit button.

Get the date-time data from the contextual bar.

Log the data to the console.

export class CtxbarExampleApp extends App {
    constructor(info: IAppInfo, logger: ILogger, accessors: IAppAccessors) {
        super(info, logger, accessors);
    }

    // [7]
    protected async extendConfiguration(configuration: IConfigurationExtend): Promise<void> {
        await configuration.slashCommands.provideSlashCommand(
            new OpenCtxBarCommand(this),
        )
    }

    // [8]
    public async executeBlockActionHandler(context: UIKitBlockInteractionContext, _read: IRead, _http: IHttp, _persistence: IPersistence, modify: IModify) {
        const data = context.getInteractionData();

        const contextualbarBlocks = createContextualBarBlocks(modify, data.container.id);

        // [9]
        await modify.getUiController().updateContextualBarView(contextualbarBlocks, { triggerId: data.triggerId }, data.user);

        return {
            success: true,
        };
    }

    // [10]
    public async executeViewSubmitHandler(context: UIKitViewSubmitInteractionContext): Promise<IUIKitResponse> {
        const data = context.getInteractionData()

        // [11]
        const text = (data.view.blocks[0] as ISectionBlock).text.text;

        // [12]
        console.log(text);

        return {
            success: true,
        };
    }
}

// Here in the main class, we setup the whole app:
// [7] first we provide the slash command we will use.
// [8] then we listen to when the button on [5] is pressed.
// [9] we update the contextual bar's content.
// [10] listen for when the user presses the 'submit' button.
// [11] get the content (date-time) from the contextual bar.
// [12] logs the data to the console.
TypeScriptCopy
Deploy and test this app by sending "/contextualbar <text>" to any channel. As soon as you send this message, the contextual bar opens on the right-side of the UI. The contextual bar displays the current date-time, the refresh button, and the submit button.

Click Refresh to update the current date-time. Clicking Submit logs the date-time to the app logs and closes the contextual bar.

Go to the Logs section of your app to view the details.

Great work! With this example, you have learned to create user interactions for your apps! While we have only used a contextual bar and buttons here, you can learn about all the building blocks that are available in the UIKit in the next section.


Create Action Buttons 
Documentation
Apps-Engine
Extend App Capabilities
Apps-Engine User Interface
Building Blocks
Create Action Buttons
In the previous sections, we have learned about creating contextual bars and the list of building blocks available in the UIKit. Let's add to this knowledge and see how to create interactive buttons and handle the interactions.

Action buttons are UIKit elements that, when registered, can be displayed and used in different contexts within the Rocket.Chat UI to trigger or initiate a set of actions. The action button context consists of the following:

MESSAGE_ACTION: The action button is displayed in the message menu. Click the kebab menu against a message to access the button.

MESSAGE_BOX_ACTION: The button is displayed in the message text menu. Click the plus icon in the message box, and the button will appear under Apps.

ROOM_ACTION: The button is displayed in the room menu. Click the kebab menu of a room to access the button.

USER_DROPDOWN_ACTION: The button is displayed under the marketplace menu under Apps on the user panel.

To demonstrate this, we will create an action button on the MESSAGE_ACTION context that will display a modal with text to let us know that the interaction was received.

Step 1: Register a button
Action buttons are registered during the extendConfiguration lifecycle method. The code snippet is as follows:

protected async extendConfiguration(configuration: IConfigurationExtend, environmentRead: IEnvironmentRead): Promise<void> {
    configuration.ui.registerButton({
        actionId: 'my-action-id', // this identifies your button in the interaction event
        labelI18n: 'my-action-name', // key of the i18n string containing the name of the button
        context: UIActionButtonContext.MESSAGE_ACTION, // the context in which the action button will be displayed on the UI. You can also try using another context to see where the button will be displayed.
    });
}
TypeScriptCopy
Add the following import statement to your file for UIActionButtonContext:

import {UIActionButtonContext } from '@rocket.chat/apps-engine/definition/ui';
TypeScriptCopy
Registering a button requires some permissions. Add the following to your app manifest file (app.json):

{
    "id": "some-app-id",
    "name": "App Name",
    // ... other definitions
    "permissions": [
        { "name": "ui.registerButtons" },
        { "name" : "ui.interact" }
    ]
}
JSONCopy
For more information, see App Permission System.

Deploy your app to test and you can see that the button gets added to the list of options against the context specified, in this case, a message.

Click on the options icon across any message, and you will see the action we just created, as seen below:


UI Kit new Action button

Step 2: Handle an interaction
After registering the button, we can see the button but cannot take any actions with it. Now whenever the user clicks the action button, we want the app to receive an interaction event.

Here is an example of how to handle it:

export class ActionbuttonApp extends App implements IUIKitInteractionHandler {
    protected async extendConfiguration(configuration: IConfigurationExtend, _environmentRead: IEnvironmentRead): Promise<void> {
        configuration.ui.registerButton({
            actionId: 'my-action-id', // this identifies your button in the interaction event
            labelI18n: 'my-action-name', // key of the i18n string containing the name of the button
            context: UIActionButtonContext.MESSAGE_ACTION
});
}
    public async executeActionButtonHandler(
        context: UIKitActionButtonInteractionContext,
        _read: IRead,
        _http: IHttp,
        _persistence: IPersistence,
        modify: IModify,
    ): Promise<IUIKitResponse> {
        const {
            buttonContext,
            actionId,
            triggerId,
            user,
            room,
            message,
        } = context.getInteractionData();

        // If you have multiple action buttons, use `actionId` to determine 
        // which one the user interacted with
        if (actionId === 'my-action-id') {
            modify.getUiController().openSurfaceView( // the method to define the modal
                {
                    type: UIKitSurfaceType.MODAL,
                    title: {
                        text: 'Interaction received', // title of the modal
                        type: 'plain_text'
                    },
                    blocks: [
                        {
                            type: 'section',
                            blockId: 'block_setion_1',
                            text: {
                                type: 'plain_text',
                                text: 'We received your interaction, thanks! :)',
                                emoji: true
                            }
                        }
                    ]
                },
                { triggerId: context.getInteractionData().triggerId },
                context.getInteractionData().user
            )
        }
        return context.getInteractionResponder().successResponse();
}}
TypeScriptCopy
Deprecated method of defining a modal


Now deploy and test the app again. You will see that when you click the action button that we had registered, a modal named Interaction received opens with the message We received your interaction, thanks!. You can also view the Logs tab of your app for details.

Step 3: Choose when your button is displayed
Most of the time, you will have an action button that does something specific and should not be displayed everywhere the context is available. For that, you can use the when prop while registering the button as follows:

protected async extendConfiguration(configuration: IConfigurationExtend, environmentRead: IEnvironmentRead): Promise<void> {
    await configuration.ui.registerButton({
        actionId: 'my-action-id',
        labelI18n: 'my-action-name',
        context: UIActionButtonContext.MESSAGE_ACTION,
        // If you want to choose `when` the button should be displayed
        when: {
            roomTypes: [
                RoomTypeFilter.PUBLIC_CHANNEL, 
                RoomTypeFilter.PRIVATE_CHANNEL, 
                RoomTypeFilter.DIRECT,
            ],
            hasOnePermission: ['create-d'],
            hasAllRoles: ['admin', 'moderator'],
        }
    });
}
TypeScriptCopy
Add the following import statement to your file for UIActionButtonContext and RoomTypeFilter:

import { RoomTypeFilter, UIActionButtonContext } from '@rocket.chat/apps-engine/definition/ui';
TypeScriptCopy
Now the button can only be seen in public and private channels and direct messages, by users that have the create-d permission and the admin role. The user must also be a moderator of the channel to see the action button for messages in that channel.

Add localization
Localization for your app is important to better suit different users. To add localization to your app, create an i18n folder in the project's root directory and add .json files for the various languages.

For this example, let us add an en.json file with the content as follows:

{
    "my-action-name": "Test UI Action"
}
JSONCopy
This code will create a reference for the English language against the labelI18n value we specified when we registered the button in the previous section.

With these changes, deploy the app again and this time you will see something like the screenshot below when the button is clicked.


UI Kit Action Button triggered

With this example, we know how to handle interactions using action buttons and specify when the button should be displayed. We've also taken a look at defining localization files here.

To create such interfaces with Apps-Engine for the Rocket.Chat UI, you need to follow some guidelines. In the next topic, you will find detailed guidelines for menus, messages, chatbots, and so on.


Apps-Engine UI Guidelines 
Documentation
Apps-Engine
Extend App Capabilities
Apps-Engine User Interface
Apps-Engine UI Guidelines
With the Apps-Engine UIKit, we have seen how to create the interactions in our apps displayed on the Rocket.Chat UI. Follow these guidelines for any interface that you are creating for your Rocket.Chat app using the Apps-Engine.

Surface types
There are two surface types:

Simple: Examples like menus that can contain only the predefined list of menu items

Complex: Examples like contextual bars and modal views can use all available UIKit components to build the intended user experience.

User menu
The user menu contains items specific to the user such as status and preferences. Every item on this menu should relate to a user.

Do add only user-specific items to this menu


User menu visual guide
Room kebab menu
The room kebab menu is located at the top-right side of any Rocket.Chat room.

This menu opens up a contextual bar and not a modal.

Items on this menu must relate to or affect the current room or its context in some way.

Don't include icons or use emojis in item labels.


Room kebab menu UI guide
Message kebab menu
The message kebab menu can be seen on the right side of a message when hovered upon on a desktop or long-pressed on a mobile device.

The message kebab menu is reserved exclusively for items that affect the selected message.

Only Rocket.Chat core actions can use icons.

Don't include icons or emojis anywhere inside the item label.

Room kebab menu UI guide
Message kebab menu UI guide
Chat messages
Make messages very clear and brief.

Do use an emoji if only they help get the intended message across.

Don't send messages on a user's behalf.

Don't over-communicate or use emojis excessively.


Chat message UI Guide
Slash commands
Slash commands are usually the simplest ways users can interact with installed apps.

Slash command descriptions should appear next to the command when typed in the message composer.

Commands must have hyphens between words and include a description.


Slash commands UI Guide
All apps using a slash command must have a /help command showing the possibilities of the app and its commands.

Contextual bars
Apps can utilize the contextual bar surface to offer information and actions to the user.

Contextual bars must contain a corresponding item in the room kebab menu.

Contextual bar titles must use sentence case capitalization eg: Google Calendar settings, not Google Calendar Settings.

Don't use images, such as app icons, inside the contextual bar header.

Don't use the title case in the contextual bar header.

Do use sentence case in contextual bar header.


Contextual bar UI Guide
Modals
Apps utilize modal dialogs to present information and actions to the user. Use contextual bars for more complex and involved interactions.

As a default setting, the app logo asset will be presented in the modals that are linked to the corresponding app.

Don't use modals without the app name in the tagline.

Do use the app name in the modal tagline.


Modals UI Guide
App (bot) username
If your app has an associated bot user, the username of that user must be identical to the app name except with a hyphen replacing any spaces in the app name. For example, if the app is a Google Calendar app, the bot username must be @google-calendar, not @google-calendar.bot or any other variation.

With these guidelines in mind, you can create functional apps that leverage the UIKit components and provide helpful user interactions. To fully apply these functionalities, you need to define the configuration and permissions for your app so that it can perform actions such as sending messages or modifying settings. Let's move on to the next sections to understand the configuration details.



